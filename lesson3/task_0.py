# 1. Удаление элемента списка во время его итерирования
N = 55
print('# 1. Удаление элемента списка во время его итерирования',
      end=f"\n{'-' * N}\n")


list_1 = [1, 2, 3, 4]
list_2 = [1, 2, 3, 4]
list_3 = [1, 2, 3, 4]
list_4 = [1, 2, 3, 4]

for i, item in enumerate(list_1):
    del item
    # del разрывает связь между переменной и объектом на который
    # эта переменная ссылается

print(f'list_1: {list_1}')

for i, item in enumerate(list_2):
    list_2.remove(item)
    # при удалении числа "1" произошло смещение указателя в цикле
    # и следующим элементом который он выдал была не "2" а "3"
    # удалив же число "3" мы не получили число "4" -> цикл завершился
print(f'list_2: {list_2}')

for i, item in enumerate(list_3):
    list_3.pop(i)
    # pop(i)с индексом в скобках работает аналогично методу ".remove"
print(f'list_3: {list_3}')

for i, item in enumerate(list_4[:]):
    list_4.remove(item)
    # использовали тот же метод ".remove" только вместо самого списка(list_4)
    # передали в цикл его срез(копию) от начала до конца
    # тоесть цикл двигался по копии объекта
    # а действия производились над оригинальным объектом
print(f'list_4: {list_4}')

# 2. Крестики-нолики, где X побеждает с первой попытки
print('# 2. Крестики-нолики, где X побеждает с первой попытки',
      end=f"\n{'-' * N}\n")


row = [''] * 3
board = [row] * 3
print(board)
board[0][0] = 'X'
print(board)
# Получили "Х" вовсех строка, дело в том что
# список имеет ссылочную структуру данных
# то есть в самом списке храняться не объекты а ссылки на эти объекты
# !Лучше использовать "генератор списков"
board = [[''] * 3 for _ in range(3)]
print(f"list_comprehensions:\n{board}")
board[0][0] = 'X'
print(board)

# 3. Те же операнды, но другая история
print('# 3. Те же операнды, но другая история',
      end=f"\n{'-' * N}\n")

a = [1, 2, 3, 4]
b = a
a = a + [5, 6, 7]   # создается новый список(объект в памяти)
# a указывает на новый объект ,
# b указывает на старый объект в памяти в котором 4 цифры
print(f"a = [1, 2, 3, 4]\nb = a\na = a + [5, 6, 7]\na->{a}, b->{b}",
      end=f"\n{'-' * int(N//2)}\n")

a = [1, 2, 3, 4]
b = a
a += [5, 6, 7]   # не создается новый список
# a указывает на старый список (объект) ,
# b указывает на старый список (объект)
print(f"a = [1, 2, 3, 4]\nb = a\na += [5, 6, 7]\na->{a}, b->{b}")


# 4. Игла в стоге сена
print('# 4. Игла в стоге сена',
      end=f"\n{'-' * N}\n")

t = ('one', 'two')
for i in t:
    print(i)

t = ('one')
for i in t:
    print(i)

t = ('one',)    # Для распечатки одного элемента кортежа
for i in t:
    print(i)


# 5. Сохранить только уникальные значения
print('# 5. Сохранить только уникальные значения',
      end=f"\n{'-' * N}\n")

lst = [1, 5, 6, 1, 6, 2, 4, 5, 1, 6, 5]
lst = list(set(lst))
print(lst)


# 6. Ключ словаря - изменяемый объект
print('# 6. Ключ словаря - изменяемый объект',
      end=f"\n{'-' * N}\n")

print("""
set_x = {1, 2, 3}
lst_x = [1, 4, 9]
dict_x = {set_x: lst_x}
or
dict_x = {lst_x: set_x}
-->
Traceback (most recent call last):
  File "task_0.py", line 110, in <module>
    dict_x = {set_x: lst_x}
    or
    dict_x = {lst_x: set_x}
TypeError: unhashable type: 'set'
""")

# использовать "frozenset" - для неизменяемого множества "set"
# использовать "tuple" - для неизменяемого списка "list"

set_x = {1, 2, 3}
lst_x = [1, 4, 9]
dict_x = {frozenset(set_x): lst_x}
dict_y = {tuple(lst_x): set_x}
